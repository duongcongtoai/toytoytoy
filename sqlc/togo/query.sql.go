// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: query.sql

package togo

import (
	"context"
	"database/sql"
	"time"
)

const createPurchase = `-- name: CreatePurchase :execresult
INSERT INTO
	purchases (wager_id, buying_price, bought_at)
VALUES
	(?, ?, ?)
`

type CreatePurchaseParams struct {
	WagerID     int64
	BuyingPrice sql.NullString
	BoughtAt    time.Time
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPurchase, arg.WagerID, arg.BuyingPrice, arg.BoughtAt)
}

const createWager = `-- name: CreateWager :execresult
INSERT INTO
	wagers (
		total_wager_value,
		odds,
		selling_percentage,
		selling_price,
		current_selling_price,
		percentage_sold,
		amount_sold,
		placed_at
	)
VALUES
	(?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWagerParams struct {
	TotalWagerValue     int32
	Odds                int32
	SellingPercentage   int32
	SellingPrice        string
	CurrentSellingPrice string
	PercentageSold      sql.NullInt32
	AmountSold          sql.NullString
	PlacedAt            time.Time
}

func (q *Queries) CreateWager(ctx context.Context, arg CreateWagerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createWager,
		arg.TotalWagerValue,
		arg.Odds,
		arg.SellingPercentage,
		arg.SellingPrice,
		arg.CurrentSellingPrice,
		arg.PercentageSold,
		arg.AmountSold,
		arg.PlacedAt,
	)
}

const getWager = `-- name: GetWager :one
SELECT
	id, total_wager_value, odds, selling_percentage, selling_price, current_selling_price, percentage_sold, amount_sold, placed_at
FROM
	wagers
WHERE
	id = ?
LIMIT
	1
`

func (q *Queries) GetWager(ctx context.Context, id int64) (Wager, error) {
	row := q.db.QueryRowContext(ctx, getWager, id)
	var i Wager
	err := row.Scan(
		&i.ID,
		&i.TotalWagerValue,
		&i.Odds,
		&i.SellingPercentage,
		&i.SellingPrice,
		&i.CurrentSellingPrice,
		&i.PercentageSold,
		&i.AmountSold,
		&i.PlacedAt,
	)
	return i, err
}

const getWagers = `-- name: GetWagers :many
SELECT
	id, total_wager_value, odds, selling_percentage, selling_price, current_selling_price, percentage_sold, amount_sold, placed_at
FROM
	wagers
ORDER BY
	placed_at DESC
LIMIT
	? OFFSET ?
`

type GetWagersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetWagers(ctx context.Context, arg GetWagersParams) ([]Wager, error) {
	rows, err := q.db.QueryContext(ctx, getWagers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wager
	for rows.Next() {
		var i Wager
		if err := rows.Scan(
			&i.ID,
			&i.TotalWagerValue,
			&i.Odds,
			&i.SellingPercentage,
			&i.SellingPrice,
			&i.CurrentSellingPrice,
			&i.PercentageSold,
			&i.AmountSold,
			&i.PlacedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWager = `-- name: UpdateWager :execresult
UPDATE
	wagers
SET
	current_selling_price = ?,
	percentage_sold = ?,
	amount_sold = ?
WHERE
	id = ?
`

type UpdateWagerParams struct {
	CurrentSellingPrice string
	PercentageSold      sql.NullInt32
	AmountSold          sql.NullString
	ID                  int64
}

func (q *Queries) UpdateWager(ctx context.Context, arg UpdateWagerParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateWager,
		arg.CurrentSellingPrice,
		arg.PercentageSold,
		arg.AmountSold,
		arg.ID,
	)
}
